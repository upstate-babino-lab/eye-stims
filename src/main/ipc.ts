import { ipcMain, app, dialog, BrowserWindow } from 'electron';
import { loadFileDialogAsync } from './menu';
import { mkdir, writeFile, readFile, readdir, access, rm } from 'fs/promises'; // TODO: import as mkdirAsync, etc.
import * as crypto from 'crypto';
import * as path from 'path';
import * as fs from 'fs';
import { theMainWindow } from '.';
import {
  addSubtitleAsync,
  buildFromCacheAsync,
  spawnFfmpegAsync,
} from './spawn-ffmpeg';
import {
  audioChoices,
  generateToneFilesAsync,
  toneBasename,
} from './generate-tones';
import { AudioKey, CHOSEN_AUDIO_KEY } from '../constants';
import { assert } from '../shared-utils';
import { exec } from 'child_process';
import { promisify } from 'util';
const execPromise = promisify(exec);

export const stimsCacheDir = path.join(app.getPath('userData'), 'stims-cache');

// Ensure the cache directory exists
// TODO: clear cacheDir if generated by a previous version of the app
export async function ensureCacheDirAsync() {
  try {
    await access(stimsCacheDir);
    const lastToneFilename =
      toneBasename(15) + audioChoices[CHOSEN_AUDIO_KEY].fileExtension;
    const lastTonePathname = path.join(
      stimsCacheDir,
      lastToneFilename || 'error-with-lastToneFilename'
    );
    await access(lastTonePathname); // Check for last tone file
    return; // No error so it's there
  } catch {
    // Need to create directory and syncTones
    await mkdir(stimsCacheDir, { recursive: true });
    console.log('>>>>> Created stim cacheDir ' + stimsCacheDir);
    await generateToneFilesAsync(stimsCacheDir, CHOSEN_AUDIO_KEY);
    // TODO: Create a cacheProps.json file with apVersion
    // This can also be used to store last built display type, average build speed, etc.
  }
}

export async function clearStimCacheAsync() {
  console.log('>>>>> Removing cacheDir ' + stimsCacheDir);
  await rm(stimsCacheDir, { recursive: true, force: true });
  await ensureCacheDirAsync();
  // Same as Electron Force Reload
  const win = BrowserWindow.getFocusedWindow();
  if (win) {
    win.webContents.reloadIgnoringCache();
  }
}

export function setupIpcHandlers() {
  ipcMain.on('loadFile', () => {
    console.log(`>>>>> main got 'loadFile'`);
    loadFileDialogAsync(theMainWindow).catch((err) => {
      console.log('ERROR from loadFileDialogAsync(): ' + err);
    });
  });

  ipcMain.on('saveFile', (_, { filePath, content }) => {
    console.log(`>>>>> main got 'saveFile'`);
    fs.writeFile(filePath, content, 'utf-8', (err) => {
      if (err) console.error('Error saving file:', err);
    });
  });

  ipcMain.handle('runFfmpeg', async (_event, args: string[]) => {
    console.log(`>>>>> main got 'runFfmpeg'`);
    return await spawnFfmpegAsync(args);
  });

  ipcMain.handle('showSaveDialog', async (_event, options) => {
    const result = await dialog.showSaveDialog(options);
    return result;
  });

  ipcMain.handle(
    'buildFromCache',
    async (
      _event,
      stimFiles: string[],
      durations: number[],
      outputFullPathname: string,
      title: string,
      description: string,
      audioKey: AudioKey = CHOSEN_AUDIO_KEY
    ) => {
      console.log(
        `>>>>> main got 'buildFromCache' with outputFilename ${outputFullPathname})`
      );
      await ensureCacheDirAsync();
      return await buildFromCacheAsync(
        stimFiles,
        durations,
        outputFullPathname,
        title,
        description,
        audioKey
      );
    }
  );

  // Save buffer to cache
  ipcMain.handle(
    'saveBufferToCache',
    async (_event, buffer: ArrayBuffer, unhashedFilename: string) => {
      // console.log(`>>>>> main got 'saveBufferToCache'`);
      try {
        await ensureCacheDirAsync();
        const filePath: string = path.join(
          stimsCacheDir,
          hashFilename(unhashedFilename)
        );
        // console.log(`>>>>> filePath=${filePath}`);
        await writeFile(filePath, Buffer.from(buffer));
        return filePath; // Return saved file path
      } catch (error) {
        console.error('Error saving buffer:', error);
        throw error;
      }
    }
  );

  ipcMain.handle(
    'addSubtitle',
    async (_event, filename, durationMs: number, text: string) => {
      return await addSubtitleAsync(filename, durationMs, text);
    }
  );

  ipcMain.handle('ensureSilentCache', async (_event, durationMs: number) => {
    return await ensureSilentFileAsync(durationMs);
  });

  ipcMain.handle('isCached', async (_event, unhashedFilename: string) => {
    // console.log(`>>>>> main got 'isCached'`);
    try {
      const hashedFilename = hashFilename(unhashedFilename);
      const filePath = path.join(stimsCacheDir, hashedFilename);
      await access(filePath); // Throws if file doesn't exist
      return filePath;
    } catch {
      return false;
    }
  });

  // Read buffer from cache
  ipcMain.handle('readFromCache', async (_event, unhashedFilename: string) => {
    // console.log(`>>>>> main got 'readFromCache'`);
    try {
      const filePath = path.join(stimsCacheDir, hashFilename(unhashedFilename));
      const data = await readFile(filePath);
      return data.buffer; // Return as ArrayBuffer
    } catch (error) {
      console.error('Error reading from cache:', error);
      throw error;
    }
  });

  ipcMain.handle('getAppVersion', async () => {
    // console.log(`>>>>> main got 'getAppVersion'`);
    return await getAppVersionAsync();
  });

  // Return array of image paths, starting with the directory selected by the user
  ipcMain.handle('scanImagesInDirectory', async () => {
    if (!theMainWindow) {
      return []; // No window to open the dialog from
    }
    const imageExtensions = [
      '.jpg',
      '.jpeg',
      '.png',
      '.gif',
      '.bmp',
      '.webp',
      '.svg',
    ];

    try {
      const userSelection = await dialog.showOpenDialog(theMainWindow, {
        properties: ['openDirectory'],
        title: 'Select a directory with images',
      });

      // If user canceled the dialog, return an empty array
      if (userSelection.canceled || userSelection.filePaths.length === 0) {
        return [];
      }
      const directoryPath = userSelection.filePaths[0];
      const files = await readdir(directoryPath);
      console.log(
        `>>>>> Scanned directory: ${directoryPath} with ${files.length} files`
      );

      // Set first element to directoryPath
      const imagePaths: string[] = [directoryPath];
      for (const file of files) {
        const fileExtension = path.extname(file).toLowerCase();
        if (imageExtensions.includes(fileExtension)) {
          imagePaths.push(path.join(directoryPath, file));
        }
      }
      console.log(`>>>>> Found ${imagePaths.length - 1} images in directory`);
      // Return array of image paths, starting with the directory path
      // The first element is the directory path
      return imagePaths;
    } catch (error) {
      console.error('Error during directory scan:', error);
      return [];
    }
  });
}

// Generate filename with same that's guaranteed to be valid on Windows, and of limited length.
function hashFilename(unhashedFilename: string): string {
  const extension = path.extname(unhashedFilename);
  const filename =
    crypto
      .createHash('sha256')
      .update(unhashedFilename)
      .digest('hex')
      .slice(0, 20) + extension;
  return filename;
}

// Return git commit string when available, else version from package.json
export async function getAppVersionAsync(): Promise<string> {
  try {
    const { stdout } = await execPromise(
      'git describe --always --long --tags --dirty',
      { encoding: 'utf-8' }
    );
    return stdout.trim();
  } catch {
    // Git command failed and might not be a git repo
    return app.getVersion();
  }
}

export function formatNumberWithLeadingZero(
  num: number,
  decimalPlaces: number
): string {
  const formatted = num.toFixed(decimalPlaces);
  if (Math.abs(num) < 1 && formatted.startsWith('.')) {
    return '0' + formatted;
  }
  return formatted;
}

export function silentBasename(durationMs: number): string {
  return 'silence-' + Math.round(durationMs);
}

export async function ensureSilentFileAsync(
  durationMs: number,
  audioKey: AudioKey = CHOSEN_AUDIO_KEY
) {
  await ensureCacheDirAsync();
  const audioProps = audioChoices[audioKey];
  const filename = silentBasename(durationMs) + audioProps.fileExtension;
  const filePath = path.join(stimsCacheDir, filename);
  try {
    await access(filePath); // Throws if file doesn't exist
    return filePath; // Cache already there
  } catch {
    // If file doesn't exist, create it.
    assert(durationMs / 1000 < 9.22337e18, 'Duration too long');
    /* prettier-ignore */
    const args = [
      '-f', 'lavfi', // Use virtual input device
      '-i', `anullsrc=channel_layout=stereo:sample_rate=${audioProps.sampleRate}`, // Silence
      '-t', `${formatNumberWithLeadingZero(durationMs / 1000, 4)}`, // Seconds
    ].concat(audioProps.ffEncode);
    args.push(filename);

    await spawnFfmpegAsync(args);
    return filePath;
  }
}
