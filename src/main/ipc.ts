import { ipcMain, app } from 'electron';
import { loadFileDialogAsync, saveFileDialogAsync } from './menu';
import { mkdir, writeFile, readFile, access, rm } from 'fs/promises'; // TODO: import as mkdirAsync, etc.
import * as crypto from 'crypto';
import * as path from 'path';
import * as fs from 'fs';
import { theMainWindow } from '.';
import { buildFromCacheAsync, spawnFfmpegAsync } from './spawn-ffmpeg';
import {
  generateDTMFWavFilesAsync,
  toneFilenames,
} from '../../tools/generate-tones';
import { DisplayKey } from '../displays';

// Generate filename that's guaranteed to be valid on Windows, and of limited length.
function hashFilename(unhashedFilename: string): string {
  const extension = path.extname(unhashedFilename);
  const filename =
    crypto
      .createHash('sha256')
      .update(unhashedFilename)
      .digest('hex')
      .slice(0, 20) + extension;
  return filename;
}

export const stimsCacheDir = path.join(app.getPath('userData'), 'stims-cache');

// Ensure the cache directory exists
// TODO: clear cacheDir if generated by a previous version of the app
export async function ensureCacheDirAsync() {
  try {
    await access(stimsCacheDir);
    for (const filename of toneFilenames()) {
      const toneFilename = path.join(stimsCacheDir, filename);
      //console.log(`>>>>> toneFilename=${toneFilename}`);
      await access(toneFilename);
    }
    return; // Everything looks good
  } catch {
    // Need to create directory and syncTones
    await mkdir(stimsCacheDir, { recursive: true });
    await generateDTMFWavFilesAsync(stimsCacheDir);
  }
}

export async function clearStimCacheAsync() {
  console.log('>>>>> Removing cacheDir ' + stimsCacheDir);
  await rm(stimsCacheDir, { recursive: true, force: true });
}

export function setupIpcHandlers() {
  ipcMain.on('loadFile', () => {
    console.log(`>>>>> main got 'loadFile'`);
    loadFileDialogAsync(theMainWindow).catch((err) => {
      console.log('ERROR from loadFileDialogAsync(): ' + err);
    });
  });

  ipcMain.on('saveFile', (_, { filePath, content }) => {
    console.log(`>>>>> main got 'saveFile'`);
    fs.writeFile(filePath, content, 'utf-8', (err) => {
      if (err) console.error('Error saving file:', err);
    });
  });

  ipcMain.handle('runFfmpeg', async (_event, args: string[]) => {
    console.log(`>>>>> main got 'runFfmpeg'`);
    return await spawnFfmpegAsync(args);
  });

  ipcMain.handle(
    'buildFromCacheAsync',
    async (
      _event,
      displayKey: DisplayKey,
      stimFiles: string[],
      startTimes: number[],
      suggestedFilename: string
    ) => {
      console.log(
        `>>>>> main got 'buildFromCacheAsync' Awaiting user's outputFilename (with suggestion ${suggestedFilename})`
      );
      ensureCacheDirAsync(); // Can generate audio while user is picking outputFullPathname
      const outputFullPathname = await saveFileDialogAsync(suggestedFilename);
      console.error(`>>>>> outputFullPathname=${outputFullPathname}`);
      return await buildFromCacheAsync(
        displayKey,
        stimFiles,
        startTimes,
        outputFullPathname
      );
    }
  );

  // Save buffer to cache
  ipcMain.handle(
    'saveBufferToCache',
    async (_event, buffer: ArrayBuffer, unhashedFilename: string) => {
      // console.log(`>>>>> main got 'saveBufferToCache'`);
      try {
        await ensureCacheDirAsync();
        const filePath: string = path.join(
          stimsCacheDir,
          hashFilename(unhashedFilename)
        );
        // console.log(`>>>>> filePath=${filePath}`);
        await writeFile(filePath, Buffer.from(buffer));
        return filePath; // Return saved file path
      } catch (error) {
        console.error('Error saving buffer:', error);
        throw error;
      }
    }
  );

  // Test if file exists in cache
  ipcMain.handle('isCached', async (_event, unhashedFilename: string) => {
    // console.log(`>>>>> main got 'isCached'`);
    try {
      const filePath = path.join(stimsCacheDir, hashFilename(unhashedFilename));
      await access(filePath); // Throws if file doesn't exist
      return filePath;
    } catch {
      return false;
    }
  });

  // Read buffer from cache
  ipcMain.handle('readFromCache', async (_event, unhashedFilename: string) => {
    // console.log(`>>>>> main got 'readFromCache'`);
    try {
      const filePath = path.join(stimsCacheDir, hashFilename(unhashedFilename));
      const data = await readFile(filePath);
      return data.buffer; // Return as ArrayBuffer
    } catch (error) {
      console.error('Error reading from cache:', error);
      throw error;
    }
  });
}
