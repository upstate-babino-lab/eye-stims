import { ipcMain, app, dialog } from 'electron';
import { loadFileDialogAsync } from './menu';
import { mkdir, writeFile, readFile, access, rm } from 'fs/promises'; // TODO: import as mkdirAsync, etc.
import * as crypto from 'crypto';
import * as path from 'path';
import * as fs from 'fs';
import { theMainWindow } from '.';
import { buildFromCacheAsync, spawnFfmpegAsync } from './spawn-ffmpeg';
import {
  generateDTMFWavFilesAsync,
  SAMPLE_RATE,
  toneFilenames,
} from './generate-tones';
import { DisplayKey } from '../displays';

export const stimsCacheDir = path.join(app.getPath('userData'), 'stims-cache');

// Ensure the cache directory exists
// TODO: clear cacheDir if generated by a previous version of the app
export async function ensureCacheDirAsync() {
  try {
    await access(stimsCacheDir);
    const filenames = toneFilenames();
    const lastToneFilename = filenames.pop();
    if (lastToneFilename) {
      await access(lastToneFilename);
    }
    /*
    for (const filename of filenames()) {
      const toneFilename = path.join(stimsCacheDir, filename);
      console.log(`>>>>> Checking for toneFilename=${toneFilename}`);
      await access(toneFilename);
    }
    */
    return; // Everything looks good
  } catch {
    // Need to create directory and syncTones
    await mkdir(stimsCacheDir, { recursive: true });
    console.log('>>>>> Created stim cacheDir ' + stimsCacheDir);
    await generateDTMFWavFilesAsync(stimsCacheDir);
  }
}

export async function clearStimCacheAsync() {
  console.log('>>>>> Removing cacheDir ' + stimsCacheDir);
  await rm(stimsCacheDir, { recursive: true, force: true });
}

export function setupIpcHandlers() {
  ipcMain.on('loadFile', () => {
    console.log(`>>>>> main got 'loadFile'`);
    loadFileDialogAsync(theMainWindow).catch((err) => {
      console.log('ERROR from loadFileDialogAsync(): ' + err);
    });
  });

  ipcMain.on('saveFile', (_, { filePath, content }) => {
    console.log(`>>>>> main got 'saveFile'`);
    fs.writeFile(filePath, content, 'utf-8', (err) => {
      if (err) console.error('Error saving file:', err);
    });
  });

  ipcMain.handle('runFfmpeg', async (_event, args: string[]) => {
    console.log(`>>>>> main got 'runFfmpeg'`);
    return await spawnFfmpegAsync(args);
  });

  ipcMain.handle('showSaveDialog', async (_event, options) => {
    const result = await dialog.showSaveDialog(options);
    return result;
  });

  ipcMain.handle(
    'buildFromCache',
    async (
      _event,
      displayKey: DisplayKey,
      stimFiles: string[],
      startTimes: number[],
      outputFullPathname: string
    ) => {
      console.log(
        `>>>>> main got 'buildFromCache' with outputFilename ${outputFullPathname})`
      );
      await ensureCacheDirAsync();
      return await buildFromCacheAsync(
        displayKey,
        stimFiles,
        startTimes,
        outputFullPathname
      );
    }
  );

  // Save buffer to cache
  ipcMain.handle(
    'saveBufferToCache',
    async (_event, buffer: ArrayBuffer, unhashedFilename: string) => {
      // console.log(`>>>>> main got 'saveBufferToCache'`);
      try {
        await ensureCacheDirAsync();
        const filePath: string = path.join(
          stimsCacheDir,
          hashFilename(unhashedFilename)
        );
        // console.log(`>>>>> filePath=${filePath}`);
        await writeFile(filePath, Buffer.from(buffer));
        return filePath; // Return saved file path
      } catch (error) {
        console.error('Error saving buffer:', error);
        throw error;
      }
    }
  );

  ipcMain.handle('ensureAudioCache', async (_event, duration: number) => {
    await ensureCacheDirAsync();
    const filename = 'silence' + duration + '.m4a';
    const filePath = path.join(stimsCacheDir, filename);
    try {
      await access(filePath); // Throws if file doesn't exist
      return filePath; // Cache already there
    } catch {
      // If file doesn't exist, create it.
      /* prettier-ignore */
      const args = [
        '-f', 'lavfi',
        '-i', `anullsrc=channel_layout=stereo:sample_rate=${SAMPLE_RATE}`, // Silence
        '-t', `${duration}`,
        '-acodec', 'aac',
        filePath,
      ];
      await spawnFfmpegAsync(args);
      return filePath;
    }
  });

  ipcMain.handle('isCached', async (_event, unhashedFilename: string) => {
    // console.log(`>>>>> main got 'isCached'`);
    try {
      const filePath = path.join(stimsCacheDir, hashFilename(unhashedFilename));
      await access(filePath); // Throws if file doesn't exist
      return filePath;
    } catch {
      return false;
    }
  });

  // Read buffer from cache
  ipcMain.handle('readFromCache', async (_event, unhashedFilename: string) => {
    // console.log(`>>>>> main got 'readFromCache'`);
    try {
      const filePath = path.join(stimsCacheDir, hashFilename(unhashedFilename));
      const data = await readFile(filePath);
      return data.buffer; // Return as ArrayBuffer
    } catch (error) {
      console.error('Error reading from cache:', error);
      throw error;
    }
  });
}

// Generate filename that's guaranteed to be valid on Windows, and of limited length.
function hashFilename(unhashedFilename: string): string {
  const extension = path.extname(unhashedFilename);
  const filename =
    crypto
      .createHash('sha256')
      .update(unhashedFilename)
      .digest('hex')
      .slice(0, 20) + extension;
  return filename;
}
