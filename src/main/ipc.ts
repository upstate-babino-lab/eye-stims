import { ipcMain, app, dialog, BrowserWindow } from 'electron';
import { loadFileDialogAsync } from './menu';
import { mkdir, writeFile, readFile, access, rm } from 'fs/promises'; // TODO: import as mkdirAsync, etc.
import * as crypto from 'crypto';
import * as path from 'path';
import * as fs from 'fs';
import { theMainWindow } from '.';
import { buildFromCacheAsync, spawnFfmpegAsync } from './spawn-ffmpeg';
import {
  audioChoices,
  generateToneFilesAsync,
  toneBasename,
} from './generate-tones';
import { DisplayKey } from '../displays';
import { AudioKey, CHOSEN_AUDIO_KEY } from '../constants';
import { assert } from 'src/shared-utils';

export const stimsCacheDir = path.join(app.getPath('userData'), 'stims-cache');

// Ensure the cache directory exists
// TODO: clear cacheDir if generated by a previous version of the app
export async function ensureCacheDirAsync() {
  try {
    await access(stimsCacheDir);
    const lastToneFilename =
      toneBasename(15) + audioChoices[CHOSEN_AUDIO_KEY].fileExtension;
    const lastTonePathname = path.join(
      stimsCacheDir,
      lastToneFilename || 'error-with-lastToneFilename'
    );
    await access(lastTonePathname); // Check for last tone file
    return; // No error so it's there
  } catch {
    // Need to create directory and syncTones
    await mkdir(stimsCacheDir, { recursive: true });
    console.log('>>>>> Created stim cacheDir ' + stimsCacheDir);
    await generateToneFilesAsync(stimsCacheDir, CHOSEN_AUDIO_KEY);
  }
}

export async function clearStimCacheAsync() {
  console.log('>>>>> Removing cacheDir ' + stimsCacheDir);
  await rm(stimsCacheDir, { recursive: true, force: true });
  // Same as Electron Force Reload
  const win = BrowserWindow.getFocusedWindow();
  if (win) {
    win.webContents.reloadIgnoringCache();
  }
}

export function setupIpcHandlers() {
  ipcMain.on('loadFile', () => {
    console.log(`>>>>> main got 'loadFile'`);
    loadFileDialogAsync(theMainWindow).catch((err) => {
      console.log('ERROR from loadFileDialogAsync(): ' + err);
    });
  });

  ipcMain.on('saveFile', (_, { filePath, content }) => {
    console.log(`>>>>> main got 'saveFile'`);
    fs.writeFile(filePath, content, 'utf-8', (err) => {
      if (err) console.error('Error saving file:', err);
    });
  });

  ipcMain.handle('runFfmpeg', async (_event, args: string[]) => {
    console.log(`>>>>> main got 'runFfmpeg'`);
    return await spawnFfmpegAsync(args);
  });

  ipcMain.handle('showSaveDialog', async (_event, options) => {
    const result = await dialog.showSaveDialog(options);
    return result;
  });

  ipcMain.handle(
    'buildFromCache',
    async (
      _event,
      displayKey: DisplayKey,
      stimFiles: string[],
      durations: number[],
      outputFullPathname: string
    ) => {
      console.log(
        `>>>>> main got 'buildFromCache' with outputFilename ${outputFullPathname})`
      );
      await ensureCacheDirAsync();
      return await buildFromCacheAsync(
        displayKey,
        stimFiles,
        durations,
        outputFullPathname
      );
    }
  );

  // Save buffer to cache
  ipcMain.handle(
    'saveBufferToCache',
    async (_event, buffer: ArrayBuffer, unhashedFilename: string) => {
      // console.log(`>>>>> main got 'saveBufferToCache'`);
      try {
        await ensureCacheDirAsync();
        const filePath: string = path.join(
          stimsCacheDir,
          hashFilename(unhashedFilename)
        );
        // console.log(`>>>>> filePath=${filePath}`);
        await writeFile(filePath, Buffer.from(buffer));
        return filePath; // Return saved file path
      } catch (error) {
        console.error('Error saving buffer:', error);
        throw error;
      }
    }
  );

  ipcMain.handle('ensureSilentCache', async (_event, durationMs: number) => {
    return await ensureSilentFileAsync(durationMs);
  });

  ipcMain.handle('isCached', async (_event, unhashedFilename: string) => {
    // console.log(`>>>>> main got 'isCached'`);
    try {
      const hashedFilename = hashFilename(unhashedFilename);
      const filePath = path.join(stimsCacheDir, hashedFilename);
      await access(filePath); // Throws if file doesn't exist
      return hashedFilename;
    } catch {
      return false;
    }
  });

  // Read buffer from cache
  ipcMain.handle('readFromCache', async (_event, unhashedFilename: string) => {
    // console.log(`>>>>> main got 'readFromCache'`);
    try {
      const filePath = path.join(stimsCacheDir, hashFilename(unhashedFilename));
      const data = await readFile(filePath);
      return data.buffer; // Return as ArrayBuffer
    } catch (error) {
      console.error('Error reading from cache:', error);
      throw error;
    }
  });
}

// Generate filename that's guaranteed to be valid on Windows, and of limited length.
function hashFilename(unhashedFilename: string): string {
  const extension = path.extname(unhashedFilename);
  const filename =
    crypto
      .createHash('sha256')
      .update(unhashedFilename)
      .digest('hex')
      .slice(0, 20) + extension;
  return filename;
}

export function formatNumberWithLeadingZero(
  num: number,
  decimalPlaces: number
): string {
  const formatted = num.toFixed(decimalPlaces);
  if (Math.abs(num) < 1 && formatted.startsWith('.')) {
    return '0' + formatted;
  }
  return formatted;
}

export function silentBasename(durationMs: number): string {
  return 'silence-' + Math.round(durationMs);
}

export async function ensureSilentFileAsync(
  durationMs: number,
  audioKey: AudioKey = CHOSEN_AUDIO_KEY
) {
  await ensureCacheDirAsync();
  const audioProps = audioChoices[audioKey];
  const filename = silentBasename(durationMs) + audioProps.fileExtension;
  const filePath = path.join(stimsCacheDir, filename);
  try {
    await access(filePath); // Throws if file doesn't exist
    return filePath; // Cache already there
  } catch {
    // If file doesn't exist, create it.
    assert(durationMs / 1000 < 9.22337e18, 'Duration too long');
    /* prettier-ignore */
    const args = [
      '-f', 'lavfi', // Use virtual input device
      '-i', `anullsrc=channel_layout=stereo:sample_rate=${audioProps.sampleRate}`, // Silence
      '-t', `${formatNumberWithLeadingZero(durationMs / 1000, 4)}`, // Seconds
    ].concat(audioProps.ffEncode);
    args.push(filename);

    await spawnFfmpegAsync(args);
    return filePath;
  }
}
